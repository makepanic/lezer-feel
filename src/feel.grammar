@precedence {
  name,
  type,
  call,
  filter @left,
  path @left,
  qname @left,
  instanceOf,
  prefix,
  exp @left,
  times @left,
  add @left,
  compare @left,
  and @left,
  or @left,
  unaryTest @cut,
  then @left,
  else @left,
  paren,
  pname
}

@top Expressions {
  expression0+
}

expression0[@dynamicPrecedence=-1, @export] {
  expression ~semi (";" | insertSemi)?
}

expression[@isGroup=Expression] {
  textualExpression |
  boxedExpression
}

textualExpression {
  ForExpression |
  IfExpression |
  QuantifiedExpression |
  Disjunction |
  Conjunction |
  Comparison |
  ArithmeticExpression |
  InstanceOfExpression |
  PathExpression |
  FilterExpression |
  FunctionInvocation |
  literal |
  VariableName ~semi insertSemi? ~varOrQname |
  kw<"?"> |
  SimplePositiveUnaryTest |
  ParenthesizedExpression
}

forExpressionStart[@export] {
  kw<"for">
}

ForInExpressions[@name=InExpressions] {
  commaSep1<ForInExpression>
}

ForInExpression[@name=InExpression] {
  inExpression<IterationContext>
}

ForExpression {
  forExpressionStart ForInExpressions ckw<"return"> expression
}

ifExpressionStart[@export] {
  kw<"if">
}

IfExpression {
  ifExpressionStart expression !then kw<"then"> expression (!else kw<"else"> expression)?
}

quantifiedExpressionStart[@export] {
  (kw<"some"> | kw<"every">)
}

QuantifiedInExpressions[@name=InExpressions] {
  commaSep1<QuantifiedInExpression>
}

QuantifiedInExpression[@name=InExpression] {
  inExpression<expression>
}

QuantifiedExpression {
  quantifiedExpressionStart QuantifiedInExpressions ckw<"satisfies"> expression
}

pathExpressionStart[@export] {
  "."
}

PathExpression {
  expression !path pathExpressionStart VariableName
}

filterExpressionStart[@export] {
  "["
}

FilterExpression {
  expression !filter filterExpressionStart expression "]"
}

InstanceOfExpression {
  expression !instanceOf kw<"instance"> ckw<"of"> Type
}

ParenthesizedExpression {
  "(" expression !paren ")"
}

Disjunction {
  expression !or kw<"or"> expression
}

Conjunction [@dynamicPrecedence=-1] {
  expression !and kw<"and"> expression
}

boxedExpression {
  List |
  FunctionDefinition |
  Context
}

inExpressionSep[@export] {
  kw<"in">
}

inExpression<Expr> {
  Name inExpressionSep Expr
}

IterationContext {
  expression (".." expression)?
}

ArithmeticExpression {
  expression !add (ArithOp<"+"> | minus) expression |
  expression !times (ArithOp<"*"> | divide) expression |
  expression !exp ArithOp<"^" | "**"> expression |
  !prefix (ArithOp<"+"> | minus) expression
}

Comparison {
  expression !compare CompareOp<"=" | "!="> expression |
  expression !compare CompareOp<">" | ">=" | "<" | "<="> expression |
  expression !compare kw<"between"> expression kw<"and"> expression |
  expression !compare kw<"in"> PositiveUnaryTest |
  expression !compare kw<"in"> "(" PositiveUnaryTests ")"
}

SimplePositiveUnaryTest {
  CompareOp<">" | ">=" | "<" | "<="> endpoint |
  Interval
}

@top UnaryTests {
  Wildcard { minus ~maybeNum } |
  PositiveUnaryTests |
  ckw<"not"> "(" PositiveUnaryTests ")"
}

PositiveUnaryTests {
  commaSep1<PositiveUnaryTest>
}

PositiveUnaryTest {
  expression
}

FunctionDefinition {
  functionDefinitionStart "(" FormalParameters ")" kw<"external">?
  FunctionBody { expression }
}

functionDefinitionStart[@export] {
  kw<"function">
}

FormalParameters {
  commaSep<FormalParameter>
}

FormalParameter {
  ParameterName (":" Type)?
}

Type {
  QualifiedName |
  SpecialType |
  ListType { ckw<"list"> !type "<" Type !type ">" } |
  ContextType { ckw<"context"> !type "<" ContextEntryTypes !type ">" } |
  FunctionType { kw<"function"> !type "<" ArgumentTypes !type ">" "->" Type }
}

ArgumentTypes {
  commaSep<ArgumentType>
}

ArgumentType {
  Type
}

ContextEntryTypes {
  commaSep1<ContextEntryType>
}

ContextEntryType {
  Name ":" Type
}

Context {
  contextStart commaSep<ContextEntry> "}"
}

contextStart[@export] {
  "{"
}

ContextEntry {
  Key ":" contextValue
}

contextValue[@export] {
  expression
}

Key {
  PropertyName |
  StringLiteral
}

DateTimeConstructor {
  ckw<"date"> |
  ckw<"date"> kw<"and"> ckw<"time"> |
  ckw<"time"> |
  ckw<"duration">
}

functionInvocationStart[@export] {
  (SpecialFunctionName | expression) !call
}

FunctionInvocation[@dynamicPrecedence=-1] {
  functionInvocationStart functionInvocationParameters
}

functionInvocationParameters[@export] {
  "(" (PositionalParameters | NamedParameters) ")"
}

NamedParameters[@dynamicPrecedence=-1] {
  commaSep1<NamedParameter>
}

NamedParameter {
  ParameterName ":" expression
}

ParameterName {
  Name
}

PositionalParameters {
  commaSep<expression>
}

endpoint {
  QualifiedName |
  simpleLiteral ~literal
}

literal[@isGroup=Literal, @export] {
  kw<"null"> |
  simpleLiteral ~literal
}

simpleLiteral {
  NumericLiteral |
  StringLiteral |
  BooleanLiteral |
  DateTimeLiteral
}

QualifiedName {
  VariableName (!qname "." VariableName)* ~varOrQname
}

Identifier {
  identifier ~ident | nameIdentifier ~ident
}

VariableName {
  Identifier (!name Identifier)*
}

NameIdentifier[@name=Identifier] {
  identifier ~ident | nameIdentifier ~ident | additionalNameSymbol
}

Name {
  NameIdentifier (!name NameIdentifier)*
}

PropertyIdentifier[@name=Identifier] {
  propertyIdentifier | additionalNameSymbol
}

PropertyName[@name=Name] {
  PropertyIdentifier (!name PropertyIdentifier)*
}

Interval {
  ( "]" | "(" | "[" ) ~interval endpoint ".." endpoint ( ")" | "[" | "]" )
}

List {
  "[" ~interval commaSep<expression> "]"
}

SpecialType {
  ckw<"days"> kw<"and"> ckw<"time"> ckw<"duration"> |
  ckw<"years"> kw<"and"> ckw<"months"> ckw<"duration"> |
  ckw<"date"> kw<"and"> ckw<"time">
}

SpecialFunctionName {
  ckw<"years"> kw<"and"> ckw<"months"> ckw<"duration"> |
  ckw<"string"> ckw<"length"> |
  ckw<"upper"> ckw<"case"> |
  ckw<"lower"> ckw<"case"> |
  ckw<"substring"> ckw<"before"> |
  ckw<"substring"> ckw<"after"> |
  ckw<"starts"> ckw<"with"> |
  ckw<"ends"> ckw<"with"> |
  ckw<"list"> ckw<"contains"> |
  ckw<"insert"> ckw<"before"> |
  ckw<"index"> ckw<"of"> |
  ckw<"distinct"> ckw<"values"> |
  ckw<"met"> ckw<"by"> |
  ckw<"overlaps"> ckw<"before"> |
  ckw<"overlaps"> ckw<"after"> |
  ckw<"finished"> ckw<"by"> |
  ckw<"started"> ckw<"by"> |
  ckw<"day"> ckw<"of"> ckw<"year"> |
  ckw<"day"> ckw<"of"> ckw<"week"> |
  ckw<"month"> ckw<"of"> ckw<"year"> |
  ckw<"week"> ckw<"of"> ckw<"year"> |
  ckw<"get"> ckw<"value"> |
  ckw<"get"> ckw<"entries">
}

DateTimeLiteral {
  DateTimeConstructor functionInvocationParameters
}

NumericLiteral {
  minus? ~maybeNum number
}

StringLiteral {
  string
}

BooleanLiteral {
  @specialize<identifier, "true" | "false">
}

kw<Term> {
  @specialize[@name={Term}]<identifier, Term>
}

ckw<Term> {
  @extend[@name={Term}]<identifier, Term>
}

commaSep1<Expr> {
  Expr ("," Expr)*
}

commaSep<Expr> {
  "" | Expr ("," Expr)*
}

@context variableTracker from "./tokens"

@external tokens propertyIdentifiers from "./tokens" {
  propertyIdentifier[@export]
}

@external tokens identifiers from "./tokens" {
  identifier[@export],
  nameIdentifier[@export]
}

@external tokens additionalNameSymbols from "./tokens" {
  additionalNameSymbol[@export]
}

@external tokens insertSemicolon from "./tokens" {
  insertSemi
}

@skip { spaces | newline | LineComment | BlockComment }

@tokens {

  spaces { $[\u0009 \u000b\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]+ }

  newline { $[\r\n\u2028\u2029] }

  LineComment { "//" ![\n]* }

  BlockComment { "/*" blockCommentRest }

  blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }

  blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }

  digit {
    $[0-9]
  }

  digits {
    digit+
  }

  divide[@name=ArithOp] { "/" }

  minus[@name=ArithOp] { "-" }

  string {
    '"' (![\\\n"] | "\\" _)* '"'?
  }

  number {
    (digits ("." digits)? | "." digits)
  }

  @precedence { BlockComment, LineComment, divide }

  @precedence {
    number,
    "."
  }

  ">" "<" ">=" "<="

  "(" ")" "[" "]" "{" "}"

  ArithOp<Expr> {
    Expr
  }

  CompareOp<Expr> {
    Expr
  }

}

@detectDelim

@external propSource feelHighlighting from "./highlight"